---
title: "Cluster analysis"
author: "`r param$author`"
date: "`r format(Sys.time(), '%B, %Y')`"
geometry: "margin=2cm"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: "hide"
    highlight: "tango"
    theme: "paper"
bibliography: "`r file.path(param$path_out, 'references.bib')`"
css: "`r file.path(param$path_to_git, 'assets/style.css')`"
---

```{r r_options, file='../../config/configuration.R'}
source(file.path(param$path_to_git,'config/configuration.R'))
message("Set R options")
```

```{r rmarkdown, file='../../config/rmarkdown_configuration.R'}
source(file.path(param$path_to_git,'config/rmarkdown_configuration.R'))
message("Set Rmarkdown options")
```

```{r, include=FALSE, cache=FALSE}
knitr::read_chunk(file.path(param$path_to_git,'scripts/export_data/text.R'))
```

```{r load_packages, warning=FALSE, message=FALSE, results='hide'}

# Load renv and virtualenvs
renv::load(file.path(param$path_to_git,"env/basic"))
renv::use_python(type = "virtualenv", name = file.path(param$path_to_git,"env/basic/virtualenvs/r-reticulate"))
#reticulate::use_virtualenv(file.path(param$path_to_git,"env/basic/virtualenvs/r-reticulate"))

# Required libraries
library(Seurat) # main
library(ggplot2) # plots
library(patchwork) # combination of plots
library(magrittr) # %>% operator
library(knitr)

```


# Read data

## Read gene annotation
Gene annotation including Ensembl IDs, gene symbols, Entrez Ids, and Seurat gene names, are loaded from a pre-prepared reference file or Ensembl. 

```{r read_gene_annotation, file='../read_data/read_gene_annotation.R'}
#source(file.path(param$path_to_git,'scripts/read_data/read_gene_annotation.R'))
message("Read gene annotation")
```

## Read scRNA-seq data
```{asis, ref.label="read_data"}
```

Here, for the project `r param$project_id`, the following data are analysed:  

```{r read_rds, eval=!is.null(param$data), file='../read_data/read_rds.R', warning=FALSE}
source(file.path(param$path_to_git,'scripts/read_data/read_rds.R'))
message("Load Seurat object from rds file")
```













<br>


<br>  

# Clustering
```{asis, ref.label="cell_clustering"}
```

```{r clustering, warning=FALSE}

# Set default clustering
n = paste0(DefaultAssay(sc), "_snn_res.", param$cluster_resolution)
sc$seurat_clusters = sc[[n, drop=TRUE]]
Seurat::Idents(sc) = sc$seurat_clusters
if (length(levels(sc$seurat_clusters)) > 1) {
  suppressWarnings({Seurat::Misc(sc, "trees") = c(Seurat::Misc(sc, "trees"), list(seurat_clusters = Seurat::Misc(sc, "trees")[[n]]))})
}

# Set up colors for default clustering
sc = ScAddLists(sc, lists=list(seurat_clusters=Misc(sc, "colour_lists")[[n]]), lists_slot="colour_lists")
param$col_clusters = Misc(sc, "colour_lists")[["seurat_clusters"]]
```

## Visualisation with UMAP {.tabset}
```{asis, ref.label="umap"}
```
For this report, you chose the resolution value `r param$cluster_resolution` as the final value for further analyses.  

### Coloured by cluster
```{r umap_by_cluster}
# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
cluster_cells = table(sc@active.ident)
cluster_labels = paste0(levels(sc@active.ident)," (", cluster_cells[levels(sc@active.ident)],")")
p = Seurat::DimPlot(sc, reduction="umap", group.by="seurat_clusters") + 
  scale_color_manual(values=param$col_clusters, labels=cluster_labels) +
  AddStyle(title="UMAP, cells coloured by cluster identity", legend_position="bottom", legend_title="Clusters")
p = LabelClusters(p, id="seurat_clusters", box=TRUE, fill="white")
p
```

### Coloured by cluster (per sample)
```{r umap_by_cluster_separately}
# Plot all samples separately
# Repel will be deactivated if there are more than six samples; otherwise the plot may crash
p = Seurat::DimPlot(sc, reduction="umap", group.by="seurat_clusters", pt.size=param$pt_size, split.by = "orig.ident", ncol = 2) +
  scale_color_manual(values=param$col_clusters, labels=cluster_labels) +
  AddStyle(title="UMAP, cells coloured by cluster identity", legend_position="bottom", legend_title="Clusters")
p = LabelClusters(p, id="seurat_clusters", box=TRUE, fill="white", repel=ifelse(length(unique(sc$orig.ident)) <= 5, TRUE, FALSE))
p
```

### Coloured by sample
```{r umap_by_sample}
sample_cells = table(sc$orig.ident)
sample_labels = paste0(levels(sc$orig.ident)," (", sample_cells[levels(sc$orig.ident)],")")
# Note: This is a hack to colour by sample but label by Cluster
p = Seurat::DimPlot(sc, reduction="umap", group.by="orig.ident") +
  scale_color_manual(values=param$col_samples, labels=sample_labels) +
  AddStyle(title="UMAP, cells coloured by sample of origin", legend_position="bottom")
p$data$seurat_clusters = sc[["seurat_clusters"]][rownames(p$data), ]
p = LabelClusters(p, id="seurat_clusters", box=TRUE, segment.color="black", fill="white")
p
```

### Coloured by sample (per sample)
```{r umap_by_sample_separately}
# Plot all samples separately
# Repel will be deactivated if there are more than six samples; otherwise the plot may crash
p = Seurat::DimPlot(sc, reduction="umap", group.by="orig.ident", pt.size=param$pt_size, split.by = "orig.ident", ncol = 2) +
  scale_color_manual(values=param$col_samples, labels=sample_labels) +
  AddStyle(title="UMAP, cells coloured by sample of origin", legend_position="bottom")
p$data$seurat_clusters = sc[["seurat_clusters"]][rownames(p$data), ]
p = LabelClusters(p, id="seurat_clusters", box=TRUE, segment.color="black", fill="white", repel=ifelse(length(unique(sc$orig.ident)) <= 5, TRUE, FALSE))
p
``` 

# Distribution of cells in clusters

```{r cells_per_cluster}
# Count cells per cluster per sample 
cell_samples = sc[[]] %>% dplyr::pull(orig.ident) %>% levels()
cell_clusters = sc[[]] %>% dplyr::pull(seurat_clusters) %>% levels()

tbl = dplyr::count(sc[[c("orig.ident", "seurat_clusters")]], orig.ident, seurat_clusters) %>% tidyr::pivot_wider(names_from="seurat_clusters", names_prefix="Cl_", values_from=n, values_fill=0) %>% as.data.frame()
rownames(tbl) = paste0(tbl[,"orig.ident"],"_n")
tbl[,"orig.ident"] = NULL

# Add percentages
tbl_perc = round(t(tbl) / colSums(tbl) * 100, 2) %>% t()
rownames(tbl_perc) = gsub(rownames(tbl_perc), pattern="_n$", replacement="_perc", perl=TRUE)
tbl = rbind(tbl, tbl_perc)

# Add enrichment
if (length(cell_samples) > 1 & length(cell_clusters) > 1) tbl = rbind(tbl, CellsFisher(sc))

# Sort
tbl = tbl[order(rownames(tbl)),, drop=FALSE]

# Plot percentages
tbl_bar = tbl[paste0(cell_samples, "_perc"), , drop=FALSE] %>% 
  tibble::rownames_to_column(var="Sample") %>%
  tidyr::pivot_longer(tidyr::starts_with("Cl"), names_to="Cluster", values_to="Percentage")
tbl_bar$Cluster = tbl_bar$Cluster %>% gsub(pattern="^Cl_", replacement="", perl=TRUE) %>% factor(levels=sc$seurat_clusters %>% levels())
tbl_bar$Sample = tbl_bar$Sample %>% gsub(pattern="_perc$", replacement="", perl=TRUE) %>% as.factor()
tbl_bar$Percentage = as.numeric(tbl_bar$Percentage)
p = ggplot(tbl_bar, aes(x=Cluster, y=Percentage, fill=Sample)) + 
  geom_bar(stat="identity" ) +
  AddStyle(title="Percentage cells of samples in clusters",
           fill=param$col_samples,
           legend_title="Sample",
           legend_position="bottom")
p
```

The following table shows the number of cells per sample and cluster:   

* n: Number of cells per sample and cluster   
* perc: Percentage of cells per sample and cluster compared to all other cells of that cluster   

In case the dataset contains 2 or more samples, we also calculate whether or not the number of cells of a sample in a cluster is significantly higher or lower than expected:      

* oddsRatio: Odds ratio calculated for cluster c1 and sample s1 as (# cells s1 in c1 / # cells not s1 in c1) / (# cells s1 not in c1 / # cells not s1 not in c1)    
* p: P-value calculated with a Fisher test to test whether "n" is higher or lower than expected  

```{r cells_per_cluster_table}
# Print table
knitr::kable(tbl, align="l", caption="Number of cells per sample and cluster") %>% 
  kableExtra::kable_styling(bootstrap_options=c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%", fixed_thead=TRUE)
```

```{r reset_default_assay}
# Reset default assay, so we won't plot integrated data
# Note: We need integrated data for UMAP, clusters
DefaultAssay(sc) = ifelse(param$norm=="SCT", param$norm, param$assay_raw)
```

# Cell Cycle Effect

How much do gene expression profiles in the dataset reflect the cell cycle phases the single cells were in? If a cell cycle score for each cell based on its expression of G2M and S phase markers was calculated, it will be displayed here. 

```{r cellCycleEffect}
# Set up colours for cell cycle effect and add to sc object
col =  GenerateColours(num_colours=length(levels(sc$Phase)), names=levels(sc$Phase), palette="ggsci::pal_npg", alphas=1)
sc = ScAddLists(sc, lists=list(Phase=col), lists_slot="colour_lists")

# Get a feeling for how many cells are affected
p1 = ggplot(sc[[]], aes(x=S.Score, y=G2M.Score, colour=Phase)) + 
  geom_point() + 
  scale_x_continuous("G1/S score") + 
  scale_y_continuous("G2/M score") + 
  AddStyle(col=Misc(sc, "colour_lists")[["Phase"]])

p2 = ggplot(sc@meta.data %>% 
              dplyr::group_by(seurat_clusters, Phase) %>% 
              dplyr::summarise(num_cells=length(Phase)), 
            aes(x=seurat_clusters, y=num_cells, fill=Phase)) + 
  geom_bar(stat="identity", position="fill") + 
  scale_x_discrete("Seurat clusters") + 
  scale_y_continuous("Fraction of cells") + 
  AddStyle(fill=Misc(sc, "colour_lists")[["Phase"]]) + 
  theme(axis.text.x = element_text(angle=45, hjust=1, vjust=1)) 

p3 = ggplot(sc[[]] %>% 
              dplyr::group_by(orig.ident, Phase) %>% 
              dplyr::summarise(num_cells=length(Phase)), 
            aes(x=orig.ident, y=num_cells, fill=Phase)) + 
  geom_bar(stat="identity", position="fill") + 
  scale_y_continuous("Fraction of cells") +
  AddStyle(fill=Misc(sc, "colour_lists")[["Phase"]]) + 
  theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1)) + xlab("")

p = p1 + p2 + p3 & theme(legend.position="bottom")
p = p + patchwork::plot_annotation(title="Cell cycle phases") + plot_layout(guides="collect")
p
```


```{r cellCycleEffect_umap_s}
if (any(!is.na(sc$Phase))) {
  
  p1 = Seurat::DimPlot(sc, group.by="Phase", pt.size=1, cols=Misc(sc, "colour_lists")[["Phase"]]) + 
    AddStyle(title="Cell cycle phases", legend_title="Phase",  xlab = "UMAP 1", ylab = "UMAP 2")
  p1$data$seurat_clusters = sc[["seurat_clusters"]][rownames(p1$data), ]
  p1 = LabelClusters(p1, id="seurat_clusters", box=TRUE, segment.color="black", fill="white")
  
  p_list = list()
  cc_features = c("S.Score", "G2M.Score", "CC.Difference")
  title = c("S phase", "G2/M phase", "S and G2/M difference")
  
  for (n in seq(cc_features)) {
  p_list[[n]] = Seurat::FeaturePlot(sc, features=cc_features[n], pt.size=1, min.cutoff="q1", max.cutoff="q99", cols=c("lightgrey", param$col)) +
    AddStyle(title=title[n], xlab = "", ylab = "")
  }
  p = p1 + patchwork::wrap_plots(p_list, ncol=1) + 
    plot_layout(widths = c(3, 1)) +
    patchwork::plot_annotation(title="UMAP coloured by") 
  p
}
```



# Cluster QC  {.tabset}
Do cells in individual clusters have particularly high counts, detected genes or mitochondrial content?


```{r clusterQC, message=FALSE}
p_list1 = list()
qc_feature = c(paste0("nCount_", param$assay_raw), paste0("nFeature_", param$assay_raw), "percent_mt", "percent_ribo")
title = c(paste0("Summed raw counts (nCount_", param$assay_raw, ", log10 scale)"), 
            paste0("Number of features with raw count > 0 (nFeature_", param$assay_raw, ", log10 scale)"),
            "Percent of mitochondrial features (percent_mt)", 
            "Percent of ribosomal features (percent_ribo)")
if ("percent_ercc" %in% colnames(sc[[]])) {
  qc_feature = c(qc_feature, "percent_ercc")
  title = c(title, "Percent of ERCC features (percent_ercc)")
}


for (n in seq(qc_feature)) {
  p1 = suppressMessages(Seurat::FeaturePlot(sc, features=qc_feature[n]) + 
                          AddStyle(title="Feature plot") + 
                          scale_colour_gradient(low="lightgrey", high=param$col))

   if (qc_feature[n]==paste0("nCount_", param$assay_raw) | qc_feature[n]==paste0("nFeature_", param$assay_raw)) {
     p1 = p1 + scale_colour_gradient(low="lightgrey", high=param$col, trans="log10")
   }
  
  p1 = LabelClusters(p1, id="ident", box=TRUE, segment.color="black", fill="white")
  
  
  p2 = ggplot(sc[[]], aes(x=.data[["seurat_clusters"]], y=.data[[qc_feature[n]]], fill=.data[["seurat_clusters"]], group=.data[["seurat_clusters"]])) + 
    geom_violin(scale="width") + 
    AddStyle(title="Violin plot (log10 scale)", fill=param$col_clusters,
           xlab="Cluster", legend_position="none")
  
  if (qc_feature[n]==paste0("nCount_", param$assay_raw) | qc_feature[n]==paste0("nFeature_", param$assay_raw)) {
    p2 = p2 + scale_y_log10()
  }
  
  
  m = c(qc_feature[n], paste0("nFeature_", param$assay_raw))
  p3 = ggplot(sc[[c(m, "seurat_clusters")]], aes(x=.data[[m[1]]], y=.data[[m[2]]], colour=.data[["seurat_clusters"]])) + 
    geom_point() + 
    AddStyle(col=param$col_clusters) + 
    facet_wrap(~seurat_clusters) +
    theme(legend.position = "none")
  

  p_list1[[n]] = (p1 | p2) / p3
  p_list1[[n]] = p_list1[[n]] + patchwork::plot_annotation(title=title[n])
}
 
```

## Number of counts 
```{r plot_clusterQC_nCount}
print(p_list1[[1]])
```

## Number of features
```{r plot_clusterQC_nfeature}
print(p_list1[[2]])
```

## Percent mitochondrial reads
```{r plot_clusterQC_mt}
print(p_list1[[3]])
```

## Percent ribosomal reads
```{r plot_clusterQC_ribosomal}
print(p_list1[[4]])
```

## Percent ERCC
```{r plot_clusterQC_ercc}
if ("percent_ercc" %in% colnames(sc[[]])) {
  print(p_list1[[5]])
} else {
  message("No ERCC controls found.")
}
```


# Cluster tree
The relationship (similarity) between clusters can be represented in a cluster tree. I find this useful to identify which clusters might be candidates for merging.

```{r cluster_tree}

# Set seurat_clusters for as default tree
sc@tools$BuildClusterTree = sc@misc$trees$seurat_clusters

# pull the tree
cluster_tree <- Tool(object = sc, slot = "BuildClusterTree")
cluster_tree$tip.label <- paste0(" Cluster ", cluster_tree$tip.label)
# plot the tree
ape::plot.phylo(x = cluster_tree, type = "c", use.edge.length = TRUE, font = 2, cex = 1.5, tip.color = sc@misc$colour_lists$seurat_clusters, edge.width = 2)

```

<br>

```{r, child='../export_data/standard_export.Rmd'}
```

<br>
<br>
<br>

```{r, child='../export_data/appendix.Rmd'}
```

