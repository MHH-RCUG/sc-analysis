---
title: "Quality assessment of scRNA seq data"
author: "`r param$author`"
date: "`r format(Sys.time(), '%B, %Y')`"
geometry: "margin=2cm"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: "hide"
    highlight: "tango"
    theme: "paper"
bibliography: "`r file.path(param$path_out, 'references.bib')`"
css: "`r file.path(param$path_to_git, 'css/style.css')`"
---

```{r r_options, file='../../scripts/configuration.R'}
source(file.path(param$path_to_git,'scripts/configuration.R'))
message("Set R options")
```

```{r rmarkdown, file='../../scripts/rmarkdown_configuration.R'}
source(file.path(param$path_to_git,'scripts/rmarkdown_configuration.R'))
message("Set Rmarkdown options")
```

```{r, include=FALSE, cache=FALSE}
knitr::read_chunk(file.path(param$path_to_git,'scripts/text.R'))
```

```{r load_packages, warning=FALSE, message=FALSE, results='hide'}

# Load renv and virtualenvs
renv::load(file.path(param$path_to_git,"env/basic"))
renv::use_python(type = "virtualenv", name = file.path(param$path_to_git,"env/basic/virtualenvs/r-reticulate"))
#reticulate::use_virtualenv(file.path(param$path_to_git,"env/basic/virtualenvs/r-reticulate"))

# Required libraries
library(Seurat) # main
library(ggplot2) # plots
library(patchwork) # combination of plots
library(magrittr) # %>% operator
library(knitr)

```


# Read data
```{asis, ref.label="read_data"}
```

## Read gene annotation
Gene annotation including Ensembl IDs, gene symbols, Entrez Ids, and Seurat gene names, are loaded from a pre-prepared reference file or Ensembl. 

```{r read_gene_annotation, file='../read_data/read_gene_annotation.R'}
source(file.path(param$path_to_git,'modules/read_data/read_gene_annotation.R'))
message("Read gene annotation")
```

## Read scRNA-seq data
We read the single-cell RNA-seq data into a Seurat object.  
Here, for the project `r param$project_id`, the following data are analysed:  

```{r read_rds, eval=!is.null(param$data), file='../read_data/read_rds.R', warning=FALSE}
source(file.path(param$path_to_git,'modules/read_data/read_rds.R'))
message("Load Seurat object from rds file")
```

```{r restructure_object, eval=!is.null(param$data), warning=FALSE}
# Transfer object into a list
sc_original = sc
sc = list()
n = param$project_id
sc[[n]] = sc_original
```

```{r download_test_dataset, eval=!is.null(param$download_test_datasets), warning=FALSE, message=FALSE}
# Download test dataset 
param$path_test_dataset=paste0(param$path_to_git, "/modules/download_test_datasets/", param$download_test_datasets, ".R")
if (file.exists(param$path_test_dataset)) {
  message(paste0("Using test dataset '", gsub('download_','', param$download_test_datasets), "'."))
  # Data output in a data subfolder of the directory where it is run 
  # Create output directories
  if (!file.exists("data")) dir.create("data", recursive=TRUE, showWarnings=FALSE)
  setwd(file.path(param$path_to_git,"data"))
  source(param$path_test_dataset)
  param$path_data = data.frame(name=list.dirs(path = file.path(param$path_to_git,"data", "counts"),
                                              full.names = FALSE, recursive = FALSE), 
                                type=c("10x"),
                                path=list.dirs(path = file.path(param$path_to_git,"data", "counts"),
                                              full.names = TRUE, recursive = FALSE))
} else {
  message("Test dataset does not exist.")
}

```

```{r read_datasets, eval=is.null(param$data), warning=FALSE, message=FALSE}
# List of Seurat objects
sc = list()

datasets = param$path_data
for (i in seq(nrow(datasets))) {
  name = datasets[i, "name"]
  type = datasets[i, "type"]
  path = datasets[i, "path"]
  suffix = datasets[i, "suffix"]
  
  # Read 10X or smartseq2
  if (type == "10x") {
    # Read 10X sparse matrix into a Seurat object
    sc = c(sc, ReadSparseMatrix(path, project=name, row_name_column=1, convert_row_names=ensembl_to_seurat_rowname, cellnames_suffix=suffix))
    
  } else if (type == "smartseq2") {
    # Read counts table into a Seurat object
    sc = c(sc, ReadCountsTable(path, project=name, row_name_column=1, convert_row_names=ensembl_to_seurat_rowname, parse_plate_information=TRUE, return_samples_as_datasets=TRUE, cellnames_suffix=suffix))
  } 
}

# Make sure that sample names are unique. If not, just prefix with the dataset name. Also set orig.ident to this name.
sample_names = names(sc)
duplicated_sample_names_idx = which(sample_names %in% sample_names[duplicated(sample_names)])
for (i in duplicated_sample_names_idx) {
  sample_names[i] = paste(head(sc[[i]][["orig.dataset", drop=TRUE]], 1), sample_names[i], sep=".")
  sc[[i]][["orig.ident"]] = sample_names[i]
}

# Set up colors for samples and add them to the sc objects
sample_names = purrr::flatten_chr(purrr::map(sc, function(s) {
  nms = unique(as.character(s[[]][["orig.ident"]]))
  return(nms) 
}))
param$col_samples = GenerateColours(num_colours=length(sample_names), names=sample_names, palette=param$col_palette_samples, alphas=1)
sc = purrr::map(sc, ScAddLists, lists=list(orig.ident=param$col_samples), lists_slot="colour_lists")

message("Read scRNA-seq data into Seurat object")
sc
```

```{r calculate_qc_metadata, file='./calculate_qc_metadata.R', warning=FALSE}
source(file.path(param$path_to_git,'modules/pre-processing/calculate_qc_metadata.R'))
message("Calculate and add QC metadata")
```

The following first table shows available metadata (columns) of the first 5 cells (rows). These metadata provide additional information about the cells in the dataset, such as the sample a cell belongs to ("orig.ident"), the number of mapped reads (“nCounts_RNA”), the number of unique genes detected ("`r paste0("nFeature_", param$assay_raw)`"), or percentage of mitochondrial genes ("percent_mt").  
The second table shows available metadata (columns) of the first 5 genes (rows). 
```{r print_metadata}
# Print cell metadata
knitr::kable(head(sc_cell_metadata), align="l", caption="Cell metadata, top 5 rows") %>%
  kableExtra::kable_styling(bootstrap_options=c("striped", "hover"))  %>% 
  kableExtra::scroll_box(width="100%")

# Print gene metadata
knitr::kable(head(sc[[1]][[param$assay_raw]][[]], 5), align="l", caption="Feature metadata, top 5 rows (only first dataset shown)") %>% 
  kableExtra::kable_styling(bootstrap_options=c("striped", "hover"))  %>% 
  kableExtra::scroll_box(width="100%")
```

<br>

# Quality control
Quality control (QC) is an important step of the pre-processing workflow for single-cell RNA-seq data. Here we assess the cell quality, i.e. the cell viability and duplicate rate to filter parameter. Moreover, we estimate possible batch effects between samples and the impact of covariates like the cell cycle phase, to determine an appropriate normalization, scaling and integration method.

```{asis, ref.label="pre-processing"}
```

```{asis, ref.label="qc"}
```

## QC covariates 
The QC metrics plots can be used to infer filter thresholds. 
Cells with very high count depth should possibly be excluded as those might be duplicates.  
Cells with very low count depth might be droplets with ambient RNA. If the dataset contains a high number of such events, it is advisable to perform additionally upstream correction for ambient RNA e.g. via SoupX `r knitcitations::citet("https://academic.oup.com/gigascience/article/9/12/giaa151/6049831?login=true")` as ambient RNA can confound the number of observed counts and adds background noise to the data.  
Cells with low count depth and high percentage of mitochondrial reads are presumably dying cells and should be filtered out as well.  
```{r qc_plot_cells, fig.height=fig_patchwork4_height}

# Create plot per QC metric
p_list = list()
for (m in cell_qc_features) {
  p_list[[m]]= ggplot(sc_cell_metadata[, c("orig.ident", m)], aes(x=.data[["orig.ident"]], y=.data[[m]], fill=.data[["orig.ident"]], group=.data[["orig.ident"]])) +
    geom_violin(scale="width")

  # Adds points for samples with less than three cells since geom_violin does not work here
  p_list[[m]] = p_list[[m]] + 
    geom_point(data=sc_cell_metadata[, c("orig.ident", m)] %>% dplyr::filter(orig.ident %in% names(which(table(sc_cell_metadata$orig.ident) < 3))), aes(x=.data[["orig.ident"]], y=.data[[m]], fill=.data[["orig.ident"]]), shape=21, size=2)
  
  # Now add style
  p_list[[m]] = p_list[[m]] + 
    AddStyle(title=m, legend_position="none", fill=param$col_samples, xlab="") + 
    theme(axis.text.x=element_text(angle=45, hjust=1))
  
  # Add filter threshold as segments to plot; min threshold lines are dashed and max threshold lines are twodashed
  if (nrow(cell_qc_thresholds[[m]]) > 0) {
    p_list[[m]] = p_list[[m]] + geom_segment(data=cell_qc_thresholds[[m]], 
                                             aes(x=as.integer(as.factor(orig.ident))-0.5, 
                                                 xend=as.integer(as.factor(orig.ident))+0.5, 
                                                 y=value, yend=value, lty=threshold), colour="firebrick") +
      scale_linetype_manual(values=setNames(c("dashed", "F1"), c("max", "min")))
  }
}
p = patchwork::wrap_plots(p_list, ncol=2) + patchwork::plot_annotation("Distribution of feature values") 
p
```

```{r qc_plot_correlation, fig.height=fig_standard2_height, warning=FALSE}
# Correlate QC metrics for cells
p_list = list()
sc_cell_metadata_plot_order = sample(1:nrow(sc_cell_metadata))

# nFeature vs nCount
m = paste0(c("nCount_", "nFeature_"), param$assay_raw)
p_list[[1]] = ggplot(sc_cell_metadata[sc_cell_metadata_plot_order, , drop=FALSE], aes(x=.data[[m[1]]], y=.data[[m[2]]], colour=.data[["orig.ident"]])) +
  geom_point(size = param$pt_size) + 
  scale_linetype_manual(values=setNames(c("dashed", "F1"), c("max", "min"))) +
  AddStyle(col=param$col_samples)
if (nrow(cell_qc_thresholds[[m[1]]]) > 0) {
  p_list[[1]] = p_list[[1]] + geom_vline(data=cell_qc_thresholds[[m[1]]], aes(xintercept=value, lty=threshold), colour="firebrick")
    
}
if (nrow(cell_qc_thresholds[[m[2]]]) > 0) {
  p_list[[1]] = p_list[[1]] + geom_hline(data=cell_qc_thresholds[[m[2]]], aes(yintercept=value, lty=threshold), colour="firebrick")
}
  

# nFeature vs percent_mt
m = c("percent_mt", paste0(c("nFeature_"), param$assay_raw))
p_list[[2]] = ggplot(sc_cell_metadata[sc_cell_metadata_plot_order, , drop=FALSE], aes(x=.data[[m[1]]], y=.data[[m[2]]], colour=.data[["orig.ident"]])) +
  geom_point(size = param$pt_size) +
  scale_linetype_manual(values=setNames(c("dashed", "F1"), c("max", "min"))) +
  AddStyle(col=param$col_samples)
if (nrow(cell_qc_thresholds[[m[1]]]) > 0) {
  p_list[[2]] = p_list[[2]] + geom_vline(data=cell_qc_thresholds[[m[1]]], aes(xintercept=value, lty=threshold), colour="firebrick")
}
if (nrow(cell_qc_thresholds[[m[2]]]) > 0) {
  p_list[[2]] = p_list[[2]] + geom_hline(data=cell_qc_thresholds[[m[2]]], aes(yintercept=value, lty=threshold), colour="firebrick")
}

# nFeature vs percent_ercc (if available)
if ("percent_ercc" %in% names(cell_qc_features)) {
  m = c("percent_ercc", paste0(c("nFeature_"), param$assay_raw))
  p_list[[3]] = ggplot(sc_cell_metadata[sc_cell_metadata_plot_order, , drop=FALSE], aes(x=.data[[m[1]]], y=.data[[m[2]]], colour=.data[["orig.ident"]])) +
    geom_point(size = param$pt_size) + 
    scale_linetype_manual(values=setNames(c("dashed", "F1"), c("max", "min"))) + 
    AddStyle(col=param$col_samples)
  if (nrow(cell_qc_thresholds[[m[1]]]) > 0) {
    p_list[[3]] = p_list[[3]] + geom_vline(data=cell_qc_thresholds[[m[1]]], aes(xintercept=value, lty=threshold), colour="firebrick")
  }
  if (nrow(cell_qc_thresholds[[m[2]]]) > 0) {
    p_list[[3]] = p_list[[3]] + geom_hline(data=cell_qc_thresholds[[m[2]]], aes(yintercept=value, lty=threshold), colour="firebrick")
  }
}

# Combine plots
p = patchwork::wrap_plots(p_list, ncol=length(p_list)) + patchwork::plot_annotation("QC covariates scatter plots") 
if (length(p_list) == 1) {
  p = p & theme(legend.position="bottom") 
} else {
  p = p + patchwork::plot_layout(guides="collect") & theme(legend.position="bottom") 
}
p
```

To save time and computational resources, we down-sample the cell number before continuing with further quality assessment. According to provided number of samples the cell number is down-sampled to 1000 cells (1 sample), 500 (2-3 samples), or 300 (4 and more samples).

```{r downsampling}
# downsample 
# according to samples number to 1000 cells (1 sample), 500 (2-3 samples), or 300 (4 and more samples)

if (length(sc) >= 4) {
  param$downsample_cells_n = 300
} else {
  if (length(sc) > 1) {
    param$downsample_cells_n = 500
  } else {
    param$downsample_cells_n = 1000
  }
}

# downsample_cells_n overwrites downsample_cells_equally
if (!is.null(param$downsample_cells_n)) {
  n = param$downsample_cells_n
} else if (param$downsample_cells_equally) {
  n = purrr::map_int(sc, ncol) %>% min()  
}

# Actual downsampling
if (!is.null(param$downsample_cells_n) | param$downsample_cells_equally) {
  sc = purrr::map(sc, function(s) {
    cells = ScSampleCells(sc=s, n=n, seed=1)
    return(subset(s, cells=cells))
  })
  
  # Adjust combined metadata accordingly
  sc_cell_metadata = sc_cell_metadata[unlist(purrr::map(sc, Cells)), ]
  
  message(paste0("Your data has been down-sampled to ", param$downsample_cells_n, " cells." ))
  print(sc)
}
```
## Estimation of batch effects
### Genes with highest expression
We next investigate whether there are individual genes that are represented by an unusually high number of counts and whether there is a difference between samples. For each cell, we first calculate the percentage of counts per gene. Subsequently, for each gene, we calculate the median value of these percentages in all cells. Genes with the highest median percentage of counts are plotted below.  
Often those genes are mitochondrial or ribosomal genes. Here rather the percentage of raw counts per gene in a cell and similarity between samples is of importance. A high percentage of of raw counts of those, presumably, less interesting genes, suggest to perform scaling of the data. Differences in percentage of of raw counts of those genes between samples might be one first indication for batch effects.  

```{r plot_highest_expression, fig.height=fig_standard_height}
# Plot only samples that we intend to keep 
sc_names = names(sc)[!(names(sc) %in% param$samples_to_drop)]
genes_highestExpr = lapply(sc_names, function(i) {
  top_ten_exp = sc[[i]][[param$assay_raw]][["counts_median"]] %>% dplyr::arrange(dplyr::desc(counts_median)) %>% head(n=10)
  return(rownames(top_ten_exp))
  }) %>%
  unlist() %>%
  unique()

genes_highestExpr_counts = purrr::map_dfc(sc[sc_names], .f=function(s) s[[param$assay_raw]][["counts_median"]][genes_highestExpr, ]) 
genes_highestExpr_counts$gene = genes_highestExpr
genes_highestExpr_counts = genes_highestExpr_counts %>% tidyr::pivot_longer(cols=all_of(sc_names))
genes_highestExpr_counts$name = factor(genes_highestExpr_counts$name, levels=sc_names)

col =  GenerateColours(num_colours=length(genes_highestExpr), names=genes_highestExpr, palette="ggsci::pal_simpsons")
p = ggplot(genes_highestExpr_counts, aes(x=name, y=value, col=gene, group=gene)) + 
  geom_point() + 
  AddStyle(title="Top 10 highest expressed genes per sample, added into one list", 
           xlab="Sample", ylab="Median % of raw counts\n per gene in a cell", 
           legend_position="bottom", 
           col=col)
if (length(unique(genes_highestExpr_counts$name))>1) p = p + geom_line()
p
```

### Variable genes

```{asis, ref.label="normalization"}
```

```{asis, ref.label="variable_genes"}
```

```{r normalization}
# Normalize data the original way
#   This is required to score cell cycle (https://github.com/satijalab/seurat/issues/1679)
if (!("data" %in% sc[[param$project_id]][["RNA"]][])) {
  source(file.path(param$path_to_git,'modules/pre-processing/normalization.R'))
}
```

```{r plot_variable_features_heights}
fig_height_vf = 5 * ceiling(length(names(sc))/2)
```

If the composition of the samples is overall similar, it would be expected that they roughly share the same variable genes.  
```{r plot_variable_features, warning=FALSE, fig.height=fig_height_vf}
# If VariableFeatures not yet present in object
# Find variable features from normalized data (unaffected by scaling)
if (!("scale.data" %in% sc[[param$project_id]][["RNA"]][]) & !param$norm=="SCT") {
  sc = purrr::map(sc, Seurat::FindVariableFeatures, selection.method="vst", nfeatures=3000, verbose=FALSE)
}

# Plot VariableFeaturePlot
p_list = purrr::map(list_names(sc), function(n) {
  top10 = head(Seurat::VariableFeatures(sc[[n]], assay=ifelse(param$norm=="SCT", param$norm, param$assay_raw)), 10)
  p = Seurat::VariableFeaturePlot(sc[[n]], 
                                  assay=ifelse(param$norm=="SCT", param$norm, param$assay_raw), 
                                  selection.method=ifelse(param$norm=="RNA", "vst", "sct"), 
                                  col=c("grey", param$col), pt.size = param$pt_size) + 
    AddStyle(title=n) + 
    theme(legend.position=c(0.2, 0.8), legend.background=element_rect(fill=alpha("white", 0.0)))
  p = LabelPoints(plot=p, points=top10, repel=TRUE, xnudge=0, ynudge=0)
  return(p)
})

p = patchwork::wrap_plots(p_list, ncol=2) + patchwork::plot_annotation("Variable genes")
p
```


```{r merge}
if (length(sc) == 1) {
  # Default assay is set automatically
  sc = sc[[1]]
  message("Your dataset contains 1 sample only. No merging/integrating required.")
} else {
  source(file.path(param$path_to_git,'modules/pre-processing/combine_samples.R'))
}
```


### Relative log expression
The data were Log normalized with a scaling factor of 10000 and samples merged into one Seurat object.
```{asis, ref.label="rel"}
```

```{r plot_RLE_raw, fig.height=fig_standard_height}

n_cells_rle_plot = 100

# Sample at most 100 cells per dataset and save their identity
cells_subset = sc[["orig.ident"]] %>% tibble::rownames_to_column() %>% 
  dplyr::group_by(orig.ident) %>% 
  dplyr::sample_n(size=min(n_cells_rle_plot, length(orig.ident))) %>% 
  dplyr::select(rowname, orig.ident)

# Plot raw data
p1 = PlotRLE(as.matrix(log2(GetAssayData(subset(sc, cells=cells_subset$rowname), assay=param$assay_raw, layer = "counts") + 1)), 
            id=cells_subset$orig.ident, 
            col=param$col_samples) + 
  labs(title="log2(raw counts + 1)")

p2 = PlotRLE(as.matrix(GetAssayData(subset(sc, cells=cells_subset$rowname), assay=param$norm, layer = "data")), 
            id=cells_subset$orig.ident, 
            col=param$col_samples) + 
  labs(title="Normalised data")

p = p1 / p2
p
```

### Principal component analysis
```{r run_pca}

if (!("scale.data" %in% sc[["RNA"]][])) {
  # Scale (default)
  all_genes = rownames(sc)
  sc = ScaleData(sc, features = all_genes)
} 

# Run pca with the variable genes
if (!("pca" %in% list_names(sc@reductions[]))) {
  # Run PCA for default normalization
  sc = Seurat::RunPCA(sc, features=Seurat::VariableFeatures(object=sc), verbose=FALSE, npcs=min(50, ncol(sc)))
}
```

These plots offer a low dimension representation of your data. 
```{r pca_dims, fig.height=fig_patchwork4_height}
# Score plots  
p1 = Seurat::DimPlot(sc, reduction="pca", group.by = "orig.ident", cols=param$col_samples, pt.size = 1, dims = c(1,2)) + 
  AddStyle(legend_position="none", title = "", xlab = "PC 1", ylab = "PC 2")
p2 = Seurat::DimPlot(sc, reduction="pca", group.by = "orig.ident", cols=param$col_samples,  pt.size = 1, dims = c(2,3)) + 
  AddStyle(legend_position="none", title = "", xlab = "PC 2", ylab = "PC 3")
p3 = Seurat::DimPlot(sc, reduction="pca", group.by = "orig.ident", cols=param$col_samples,  pt.size = 1, dims = c(3,4)) + 
  AddStyle(legend_position="none", title = "", xlab = "PC 3", ylab = "PC 4")
p4 = Seurat::DimPlot(sc, reduction="pca", group.by = "orig.ident", cols=param$col_samples,  pt.size = 1, dims = c(4,5)) + 
  AddStyle(legend_position="bottom", title = "", xlab = "PC 4", ylab = "PC 5")
p = (p1 + p2) / (p3 + p4) +  
  plot_annotation(title = 'Cells arranged by the first five PCs') 
p
```
```{r pca_loadings, fig.height=14}
p_list = Seurat::VizDimLoadings(sc, dims=1:12, reduction="pca", col=param$col, combine=FALSE, balanced=TRUE)
for (i in seq(p_list)) p_list[[i]] = p_list[[i]] + AddStyle(xlab = paste0("PC ",i))
p =  patchwork::wrap_plots(p_list, ncol=4) + patchwork::plot_annotation("Top gene loadings of the first two PCs") 
p
```

If we run a PCA on our object, using the variable genes we found in FindVariableGenes above, we see that while most of the variance can be explained by lineage, PC4 is split on cell-cycle genes including TOP2A and MKI67. We will attempt to regress this signal from the data, so that cell-cycle heterogneity does not contribute to PCA or downstream analysis



```{r dimensionality, fig.height=fig_standard_height}
# More approximate technique used to reduce computation time
p = Seurat::ElbowPlot(sc, ndims=min(20, ncol(sc))) + 
  geom_vline(xintercept=param$pc_n + .5, col="firebrick", lty=2) + 
  AddStyle(title="Elbow plot") 
p

# Cannot have more PCs than number of cells
param$pc_n = min(param$pc_n, ncol(sc))
```

## Umap

```{r umap, fig.height=fig_standard3_height}
# Generate UMAP
if (!("umap" %in% list_names(sc@reductions[]))) {
  # Default UMAP
  sc = suppressWarnings(Seurat::RunUMAP(sc, dims=1:param$pc_n, verbose=FALSE, umap.method="uwot", n.neighbors=param$umap_k))
}

# Plot umap colored by sample
p1 = Seurat::DimPlot(sc, reduction="umap", group.by="orig.ident", pt.size = param$pt_size, cols = param$col_samples) +
  AddStyle(title="Cells coloured by sample", legend_position="right", xlab = "UMAP 1", ylab = "UMAP 2")

# Number of counts 
qc_feature = paste0("nCount_", param$assay_raw)
p2 = suppressMessages(Seurat::FeaturePlot(sc, features=qc_feature, pt.size = param$pt_size) + 
  AddStyle(title="Number of counts", legend_position="right", xlab = "UMAP 1", ylab = "UMAP 2") + 
  scale_colour_gradient(low=param$col_bg, high=param$col, trans="log10"))

# Number of features
qc_feature = paste0("nFeature_", param$assay_raw)
p3 = suppressMessages(Seurat::FeaturePlot(sc, features=qc_feature, pt.size = param$pt_size) + 
  AddStyle(title="Number of features", legend_position="right", xlab = "UMAP 1", ylab = "UMAP 2") + 
  scale_colour_gradient(low=param$col_bg, high=param$col, trans="log10"))

# Percent mitochondrial reads
p4 = Seurat::FeaturePlot(sc, features="percent_mt", cols=c(param$col_bg, param$col), pt.size = param$pt_size) + 
  AddStyle(title="% mitochondrial reads", legend_position="right", xlab = "UMAP 1", ylab = "UMAP 2")

# Percent ribosomal reads
p5 = Seurat::FeaturePlot(sc, features="percent_ribo", cols=c(param$col_bg, param$col), pt.size = param$pt_size) +
  AddStyle(title="% ribosomal reads", legend_position="right", xlab = "UMAP 1", ylab = "UMAP 2")

p = (p1 + (p2 / p3) + (p4 / p5)) + 
    plot_layout(widths = c(5, 2, 2))
p

```

### Expression of apopsote related genes 

```{r apoptpsis, fig.height=fig_patchwork8_height, warning=FALSE}
# Feature plots of target genes
if (param$species=="human") {
  apo_genes = c("BCL2", "BIRC5", "CASP3", "TP53")
} else {
  apo_genes = c("Bcl2", "Birc5", "Casp3", "Tp53")
}

p1 = suppressMessages(Seurat::FeaturePlot(sc, features=apo_genes, cols=c(param$col_bg, param$col), pt.size = param$pt_size, combine = FALSE))
p1 = AddStyleMultiFeaturePlot(p1, title = 'UMAP projection of gene expression', ncol = 4)

p2 = suppressMessages(Seurat::VlnPlot(sc, features=apo_genes, group.by = "orig.ident", slot = "counts", log = TRUE, cols = param$col_samples, combine = FALSE))
p2 = AddStyleMultiVln(p2, title = 'Expression levels', ncol = 4)

p = p1 / p2 
p
```


## Cell Cycle Effect
```{asis, ref.label="cc-removal"}
```

The following plots can help to evaluate the necessity to regress out cell cycle effects during scaling.  
An indication to consider removal of cell cycle effects would be a strong differences between samples or if cells in the same cell cycle phase form very distinctive clusters. Nevertheless, the final decision also depends on the biological system and scientific question.  
```{r cellCycleEffect, fig.height=fig_standard2_height}
# Score cell cycle effects after merge
sc = CCScoring(sc=sc, genes_s=genes_s[,2], genes_g2m=genes_g2m[,2])

# Set up colours for cell cycle effect and add to sc object
col =  GenerateColours(num_colours=length(levels(sc$Phase)), names=levels(sc$Phase), palette="ggsci::pal_npg", alphas=1)
sc = ScAddLists(sc, lists=list(Phase=col), lists_slot="colour_lists")

# Plot umap colored by cell cycle phase
p1 = Seurat::DimPlot(sc, reduction="umap", group.by="Phase", pt.size = param$pt_size) +
  AddStyle(title="", xlab = "UMAP 1", ylab = "UMAP 2") +
  NoLegend()

# Plot umap colored by cell cycle phase
p2 = Seurat::DimPlot(sc, reduction="umap", group.by="Phase", split.by = "Phase", pt.size = param$pt_size, ncol = 1) +
  AddStyle(title="", xlab = "UMAP 1", ylab = "UMAP 2") +
  NoLegend()

# Fraction of cells per cell cycle phase
p3 = ggplot(sc[[]] %>% 
              dplyr::group_by(orig.ident, Phase) %>% 
              dplyr::summarise(num_cells=length(Phase)), 
            aes(x=orig.ident, y=num_cells, fill=Phase)) + 
  geom_bar(stat="identity", position="fill") + 
  scale_y_continuous("Fraction of cells") +
  AddStyle(fill=Misc(sc, "colour_lists")[["Phase"]]) + 
  theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1, size = 12)) + xlab("")

p = p1 + p2 + plot_spacer() + p3 + 
  plot_layout(widths = c(3, 1, 1, 1)) + 
  patchwork::plot_annotation(title="Cell cycle phases") 
p
```





<br>
<br>
<br>




```{r, child='../../scripts/appendix.Rmd'}
```

